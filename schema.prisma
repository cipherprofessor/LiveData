// Tej India - PostgreSQL Database Schema
// Peer-to-Peer Skill Exchange Platform

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [postgis]
}

// ============================================
// USER MANAGEMENT
// ============================================

model User {
  id                String    @id @default(uuid())
  email             String    @unique
  passwordHash      String
  firstName         String
  lastName          String
  phoneNumber       String?   @unique
  dateOfBirth       DateTime?
  gender            Gender?
  profileImage      String?
  bio               String?   @db.Text

  // Location
  city              String?
  state             String?
  country           String    @default("India")
  pincode           String?
  latitude          Decimal?  @db.Decimal(10, 8)
  longitude         Decimal?  @db.Decimal(11, 8)

  // Gamification
  skillCoins        Int       @default(0)
  swapsCompleted    Int       @default(0)
  totalHoursTaught  Int       @default(0)
  totalHoursLearned Int       @default(0)
  rating            Decimal   @default(0) @db.Decimal(3, 2)
  totalRatings      Int       @default(0)

  // Premium
  isPremium         Boolean   @default(false)
  premiumExpiresAt  DateTime?

  // Verification
  emailVerified     Boolean   @default(false)
  phoneVerified     Boolean   @default(false)
  emailVerifyToken  String?   @unique
  passwordResetToken String?  @unique
  passwordResetExpires DateTime?

  // Relations
  skillsToTeach     UserSkill[]       @relation("TeacherSkills")
  skillsToLearn     UserSkill[]       @relation("LearnerSkills")
  swapsAsUser1      Swap[]            @relation("User1Swaps")
  swapsAsUser2      Swap[]            @relation("User2Swaps")
  badges            UserBadge[]
  reviewsReceived   Review[]          @relation("ReviewsReceived")
  reviewsGiven      Review[]          @relation("ReviewsGiven")
  sentMessages      Message[]         @relation("SentMessages")
  receivedMessages  Message[]         @relation("ReceivedMessages")
  connections       Connection[]      @relation("UserConnections")
  connectedBy       Connection[]      @relation("ConnectedUsers")
  eventsCreated     Event[]           @relation("EventOrganizer")
  eventAttendances  EventAttendance[]
  notifications     Notification[]

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([email])
  @@index([city, state])
  @@index([skillCoins(sort: Desc)])
  @@index([swapsCompleted(sort: Desc)])
  @@index([rating(sort: Desc)])
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

// ============================================
// SKILLS & CATEGORIES
// ============================================

model SkillCategory {
  categoryId    String   @id @default(uuid())
  name          String   @unique
  slug          String   @unique
  description   String?  @db.Text
  icon          String?
  color         String?
  order         Int      @default(0)

  skills        Skill[]

  createdAt     DateTime @default(now())

  @@index([slug])
  @@index([order])
}

model Skill {
  skillId       String         @id @default(uuid())
  name          String         @unique
  slug          String         @unique
  description   String?        @db.Text
  category      SkillCategory  @relation(fields: [categoryId], references: [categoryId])
  categoryId    String
  isPremium     Boolean        @default(false)
  popularity    Int            @default(0)

  userSkills    UserSkill[]

  createdAt     DateTime       @default(now())

  @@index([slug])
  @@index([categoryId])
  @@index([popularity(sort: Desc)])
  @@index([isPremium])
}

model UserSkill {
  userSkillId     String           @id @default(uuid())
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade, name: "TeacherSkills")
  userId          String
  skill           Skill            @relation(fields: [skillId], references: [skillId])
  skillId         String
  skillType       SkillType
  proficiency     ProficiencyLevel @default(BEGINNER)
  hoursExperience Int?
  verified        Boolean          @default(false)
  verifiedAt      DateTime?

  createdAt       DateTime         @default(now())

  @@unique([userId, skillId, skillType])
  @@index([userId, skillType])
  @@index([skillId, skillType])
}

enum SkillType {
  TEACH
  LEARN
}

enum ProficiencyLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
  MASTER
}

// ============================================
// SWAPS & SESSIONS
// ============================================

model Swap {
  swapId              String        @id @default(uuid())

  user1               User          @relation("User1Swaps", fields: [user1Id], references: [id])
  user1Id             String
  skill1Name          String

  user2               User          @relation("User2Swaps", fields: [user2Id], references: [id])
  user2Id             String
  skill2Name          String

  status              SwapStatus    @default(PENDING)

  startDate           DateTime?
  endDate             DateTime?
  sessionsPlanned     Int           @default(8)
  sessionsCompleted   Int           @default(0)
  hoursPlanned        Int           @default(8)
  hoursCompleted      Int           @default(0)

  meetingMode         MeetingMode   @default(HYBRID)
  meetingLocation     String?       @db.Text

  user1Rating         Decimal?      @db.Decimal(3, 2)
  user2Rating         Decimal?      @db.Decimal(3, 2)
  user1Review         String?       @db.Text
  user2Review         String?       @db.Text

  sessions            SwapSession[]

  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  @@index([user1Id, status])
  @@index([user2Id, status])
  @@index([status])
  @@index([createdAt(sort: Desc)])
}

enum SwapStatus {
  PENDING
  ACCEPTED
  ACTIVE
  COMPLETED
  CANCELLED
  DISPUTED
}

enum MeetingMode {
  ONLINE
  OFFLINE
  HYBRID
}

model SwapSession {
  sessionId     String    @id @default(uuid())
  swap          Swap      @relation(fields: [swapId], references: [swapId], onDelete: Cascade)
  swapId        String
  sessionNumber Int
  sessionDate   DateTime
  duration      Int       // in minutes
  completed     Boolean   @default(false)
  notes         String?   @db.Text

  createdAt     DateTime  @default(now())
  completedAt   DateTime?

  @@index([swapId])
  @@index([sessionDate])
}

// ============================================
// GAMIFICATION
// ============================================

model Badge {
  badgeId       String        @id @default(uuid())
  name          String        @unique
  slug          String        @unique
  description   String        @db.Text
  icon          String
  category      BadgeCategory
  rarity        BadgeRarity   @default(COMMON)
  skillCoins    Int           @default(0)
  requirement   Json          // Store complex requirements as JSON

  users         UserBadge[]

  createdAt     DateTime      @default(now())

  @@index([category])
  @@index([rarity])
  @@index([slug])
}

enum BadgeCategory {
  ACHIEVEMENT
  TEACHING
  LEARNING
  COMMUNITY
  MILESTONE
  SPECIAL
}

enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

model UserBadge {
  userBadgeId   String   @id @default(uuid())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  badge         Badge    @relation(fields: [badgeId], references: [badgeId])
  badgeId       String
  earnedAt      DateTime @default(now())

  @@unique([userId, badgeId])
  @@index([userId])
  @@index([earnedAt(sort: Desc)])
}

// ============================================
// REVIEWS & RATINGS
// ============================================

model Review {
  reviewId      String   @id @default(uuid())
  reviewer      User     @relation("ReviewsGiven", fields: [reviewerId], references: [id])
  reviewerId    String
  reviewee      User     @relation("ReviewsReceived", fields: [revieweeId], references: [id])
  revieweeId    String
  swapId        String?
  rating        Int      // 1-5 stars
  comment       String?  @db.Text
  helpful       Int      @default(0)

  createdAt     DateTime @default(now())

  @@index([revieweeId])
  @@index([reviewerId])
  @@index([rating])
  @@index([createdAt(sort: Desc)])
}

// ============================================
// CONNECTIONS & CHAT
// ============================================

model Connection {
  connectionId      String           @id @default(uuid())
  user              User             @relation("UserConnections", fields: [userId], references: [id], onDelete: Cascade)
  userId            String
  connectedUser     User             @relation("ConnectedUsers", fields: [connectedUserId], references: [id], onDelete: Cascade)
  connectedUserId   String
  status            ConnectionStatus @default(PENDING)

  createdAt         DateTime         @default(now())
  acceptedAt        DateTime?

  @@unique([userId, connectedUserId])
  @@index([userId, status])
  @@index([connectedUserId, status])
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

model Message {
  messageId     String   @id @default(uuid())
  sender        User     @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  senderId      String
  recipient     User     @relation("ReceivedMessages", fields: [recipientId], references: [id], onDelete: Cascade)
  recipientId   String
  content       String   @db.Text
  read          Boolean  @default(false)
  readAt        DateTime?

  createdAt     DateTime @default(now())

  @@index([senderId, recipientId])
  @@index([recipientId, read])
  @@index([createdAt(sort: Desc)])
}

// ============================================
// EVENTS
// ============================================

model Event {
  eventId       String            @id @default(uuid())
  organizer     User              @relation("EventOrganizer", fields: [organizerId], references: [id])
  organizerId   String
  title         String
  description   String            @db.Text
  date          DateTime
  location      String
  city          String
  state         String?
  latitude      Decimal?          @db.Decimal(10, 8)
  longitude     Decimal?          @db.Decimal(11, 8)
  maxAttendees  Int               @default(50)
  imageUrl      String?

  attendances   EventAttendance[]

  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  @@index([city])
  @@index([date])
  @@index([organizerId])
}

model EventAttendance {
  attendanceId  String           @id @default(uuid())
  event         Event            @relation(fields: [eventId], references: [eventId], onDelete: Cascade)
  eventId       String
  user          User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  status        AttendanceStatus @default(REGISTERED)

  registeredAt  DateTime         @default(now())

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
}

enum AttendanceStatus {
  REGISTERED
  ATTENDED
  CANCELLED
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  notificationId String           @id @default(uuid())
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  type           NotificationType
  title          String
  message        String           @db.Text
  data           Json?            // Additional data as JSON
  read           Boolean          @default(false)
  readAt         DateTime?

  createdAt      DateTime         @default(now())

  @@index([userId, read])
  @@index([createdAt(sort: Desc)])
}

enum NotificationType {
  SWAP_REQUEST
  SWAP_ACCEPTED
  SWAP_COMPLETED
  MESSAGE
  BADGE_EARNED
  REVIEW
  EVENT_REMINDER
  SYSTEM
}

// ============================================
// AUDIT LOGS
// ============================================

model AuditLog {
  logId         String   @id @default(uuid())
  userId        String?
  action        String
  entity        String
  entityId      String?
  changes       Json?
  ipAddress     String?
  userAgent     String?

  createdAt     DateTime @default(now())

  @@index([userId])
  @@index([entity, entityId])
  @@index([createdAt(sort: Desc)])
}
